"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[8409],{5204:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>a,contentTitle:()=>r,default:()=>h,frontMatter:()=>c,metadata:()=>i,toc:()=>d});var o=n(4848),s=n(8453);const c={sidebar_position:4},r="Text",i={id:"documents/text",title:"Text",description:"Automerge provides support for collaborative text editing. Under the hood, whenever you create a string in Automerge you are creating a collaborative text object which supports merging concurrent changes to the string.",source:"@site/docs/documents/text.md",sourceDirName:"documents",slug:"/documents/text",permalink:"/docs/documents/text",draft:!1,unlisted:!1,editUrl:"https://github.com/automerge/automerge.github.io/edit/main/docs/documents/text.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"Lists",permalink:"/docs/documents/lists"},next:{title:"Rich Text",permalink:"/docs/documents/rich_text"}},a={},d=[{value:"Using <code>updateText</code> when you can&#39;t use <code>splice</code>",id:"using-updatetext-when-you-cant-use-splice",level:2}];function l(e){const t={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.h1,{id:"text",children:"Text"}),"\n",(0,o.jsxs)(t.p,{children:["Automerge provides support for collaborative text editing. Under the hood, whenever you create a ",(0,o.jsx)(t.code,{children:"string"})," in Automerge you are creating a collaborative text object which supports merging concurrent changes to the ",(0,o.jsx)(t.code,{children:"string"}),"."]}),"\n",(0,o.jsx)(t.admonition,{type:"note",children:(0,o.jsxs)(t.p,{children:["This is only true in the ",(0,o.jsx)(t.code,{children:"next"})," API. In the original API collaborative text was represented by the ",(0,o.jsx)(t.code,{children:"Automerge.Text"})," class. See the ",(0,o.jsx)(t.a,{href:"../../the_js_packages#the-next-api",children:"next API"})," section for more details."]})}),"\n",(0,o.jsxs)(t.p,{children:["If you want changes to a ",(0,o.jsx)(t.code,{children:"string"})," to be collaborative, you should use ",(0,o.jsx)(t.code,{children:"Automerge.splice"})," to modify the string."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:'import { next as Automerge } from "@automerge/automerge"\n\nlet doc = Automerge.from({text: "hello world"})\n\n// Fork the doc and make a change\nlet forked = Automerge.clone(doc)\nforked = Automerge.change(forked, d => {\n    // Insert \' wonderful\' at index 5, don\'t delete anything\n    Automerge.splice(d, ["text"], 5, 0, " wonderful")\n})\n\n// Make a concurrent change on the original document\ndoc = Automerge.change(doc, d => {\n    // Insert at the start, delete 5 characters (the "hello")\n    Automerge.splice(d, ["text"], 0, 5, "Greetings")\n})\n\n// Merge the changes\ndoc = Automerge.merge(doc, forked)\n\nconsole.log(doc.text) // "Greetings wonderful world"\n'})}),"\n",(0,o.jsxs)(t.h2,{id:"using-updatetext-when-you-cant-use-splice",children:["Using ",(0,o.jsx)(t.code,{children:"updateText"})," when you can't use ",(0,o.jsx)(t.code,{children:"splice"})]}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.code,{children:"splice"})," works in terms of low level input events, sometimes it's hard to get hold of these. For example, in a simple web form the ",(0,o.jsx)(t.code,{children:"input"})," event is fired every time an ",(0,o.jsx)(t.code,{children:"input"})," element changes, but the value of the event is the whole content of the text box. In this case you can use ",(0,o.jsx)(t.code,{children:"Automerge.updateText"}),", which will figure out what has changed for you and convert the changes into ",(0,o.jsx)(t.code,{children:"splice"})," operations internally."]}),"\n",(0,o.jsx)(t.p,{children:"Imagine you have a simple text box:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-html",children:'<input id="myInput" type="text" value="hello world">\n'})}),"\n",(0,o.jsxs)(t.p,{children:["Then with this HTML you can use ",(0,o.jsx)(t.code,{children:"updateText"})," to make the text box collaborative:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-typescript",children:'\nconst handle: DocHandle<{text: string}> = ... // some how get a DocHandle\n\nconst input = document.getElementById("input")!\n\ninput.value = handle.docSync()!.text!\n\n// On every keystroke use `updateText` to update the value of the text field\ninput.oninput = (e) => {\n    handle.change((doc) => {\n        // @ts-ignore\n        const newValue: string = e.target.value\n        console.log("newValue", newValue)\n        am.updateText(doc, ["text"], newValue)\n    })\n}\n\n// Any time the document changes, update the value of the text field\nhandle.on("change", () => {\n    // @ts-ignore\n    input.value = handle.docSync()!.text!\n})\n'})}),"\n",(0,o.jsx)(t.admonition,{type:"warning",children:(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.code,{children:"updateText"})," works best when you call it as frequently as possible. If the text has changed a lot between calls to ",(0,o.jsx)(t.code,{children:"updateText"})," (for example if you were calling it in ",(0,o.jsx)(t.code,{children:"onchange"}),") the diff will not merge well with concurrent changes. The best case is to call it after every keystroke."]})})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>i});var o=n(6540);const s={},c=o.createContext(s);function r(e){const t=o.useContext(c);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),o.createElement(c.Provider,{value:t},e.children)}}}]);