"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[3788],{3435:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>i,toc:()=>c});var a=n(4848),r=n(8453);const s={sidebar_position:5},o="Rich Text",i={id:"documents/rich_text",title:"Rich Text",description:"As well as supporting plain text Automerge supports rich text editing. The rich text APIs are extensions of the plain text API. In addition to using splice and updateText to modify a string, we also provide functions to manipulate two extra data types which are associated with a string:",source:"@site/docs/documents/rich_text.md",sourceDirName:"documents",slug:"/documents/rich_text",permalink:"/docs/documents/rich_text",draft:!1,unlisted:!1,editUrl:"https://github.com/automerge/automerge.github.io/edit/main/docs/documents/rich_text.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5},sidebar:"tutorialSidebar",previous:{title:"Text",permalink:"/docs/documents/text"},next:{title:"Conflicts",permalink:"/docs/documents/conflicts"}},d={},c=[{value:"Marks",id:"marks",level:2},{value:"Block Markers",id:"block-markers",level:2},{value:"The Spans API",id:"the-spans-api",level:2},{value:"Reading spans",id:"reading-spans",level:3},{value:"Updating spans",id:"updating-spans",level:3}];function l(e){const t={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.h1,{id:"rich-text",children:"Rich Text"}),"\n",(0,a.jsxs)(t.p,{children:["As well as ",(0,a.jsx)(t.a,{href:"../text",children:"supporting"})," plain text Automerge supports rich text editing. The rich text APIs are extensions of the plain text API. In addition to using ",(0,a.jsx)(t.code,{children:"splice"})," and ",(0,a.jsx)(t.code,{children:"updateText"})," to modify a string, we also provide functions to manipulate two extra data types which are associated with a string:"]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Marks: formatting spans which apply to a range of characters and can overlap"}),"\n",(0,a.jsx)(t.li,{children:"Block markers which divide the text into blocks"}),"\n"]}),"\n",(0,a.jsx)(t.h2,{id:"marks",children:"Marks"}),"\n",(0,a.jsx)(t.p,{children:'Marks represent things like bold or italic text, or inline elements such as hyperlinks. Every mark has a name - such as "bold" - and a value, which must be a primitive value such as a boolean or string.'}),"\n",(0,a.jsx)(t.p,{children:"When you create a mark you must decide how that mark will behave when characters are inserted at its boundaries. For example, bold marks typically expand when characters are inserted at the boundaries whilst a hyperlink normally wouldn't."}),"\n",(0,a.jsxs)(t.p,{children:["To create a mark, call ",(0,a.jsx)(t.code,{children:"Automerge.mark"})," with the start and end of the range, the name of the mark, the value of the mark, and an ",(0,a.jsx)(t.code,{children:"expand"})," option. You can obtain the set of active marks on a string by calling ",(0,a.jsx)(t.code,{children:"Automerge.marks"}),"."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-typescript",children:'import { next as Automerge } from "@automerge/automerge"\n\nlet doc = Automerge.from({text: "hello world"})\n\nAutomerge.change(doc, d => {\n    Automerge.mark(d, ["text"], {start: 0, end: 5, expand: "both"}, "bold", true)\n})\n\nconsole.log(Automerge.marks(doc, ["text"]))\n\n>> [ { name: \'bold\', value: true, start: 0, end: 5 } ]\n'})}),"\n",(0,a.jsx)(t.p,{children:'Here we can see that the bold span applies to the "hello".'}),"\n",(0,a.jsxs)(t.p,{children:["It is up to your application to decide what different mark names mean, but if you are interested in interoperability consider adopting our ",(0,a.jsx)(t.a,{href:"../../under-the-hood/rich_text_schema",children:"rich text schema"}),"."]}),"\n",(0,a.jsx)(t.h2,{id:"block-markers",children:"Block Markers"}),"\n",(0,a.jsxs)(t.p,{children:["Block markers are maps which are inserted inline in the text. They are used to divide text into structural roles such as paragraphs, headings, or code blocks. The underlying primitive of a block marker is very flexible, so specific editor integrations can use it however they like. The ",(0,a.jsx)(t.code,{children:"automerge-prosemirror"})," bindings use the ",(0,a.jsx)(t.a,{href:"../../under-the-hood/rich_text_schema",children:"rich text schema"}),"."]}),"\n",(0,a.jsxs)(t.p,{children:["Block markers can be created using ",(0,a.jsx)(t.code,{children:"Automerge.splitBlock"})," and updated using ",(0,a.jsx)(t.code,{children:"Automerge.updateBlock"})," and you can find the active block at a given index using ",(0,a.jsx)(t.code,{children:"Automerge.block"}),"."]}),"\n",(0,a.jsx)(t.h2,{id:"the-spans-api",children:"The Spans API"}),"\n",(0,a.jsx)(t.h3,{id:"reading-spans",children:"Reading spans"}),"\n",(0,a.jsxs)(t.p,{children:["Frequently working directly with block markers and spans is tedious. You can use ",(0,a.jsx)(t.code,{children:"Automerge.spans"})," to retrieve a sequence of text spans grouped by their marks and interspersed with block markers. For example"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-typescript",children:'import { next as Automerge } from "@automerge/automerge"\n\nlet doc = Automerge.from({text: ""})\n\ndoc = Automerge.change(doc, d => {\n    // Insert an opening paragraph block\n    Automerge.splitBlock(d, ["text"], 0, {type: "paragraph", parents: []})\n    // Note that the block markers appear inline in the text and so to insert \n    // _after_ the block marker we need to insert at position 1\n    Automerge.splice(d, ["text"], 1, 0, "Hello")\n    // Insert another paragraph\n    Automerge.splitBlock(d, ["text"], 6, {type: "paragraph", parents: []})\n    Automerge.splice(d, ["text"], 1, 0, "world")\n\n    // Add a mark which covers the end of "hello" and the start of "world"\n    Automerge.mark(d, ["text"], {start: 4, end: 8, expand: "both"}, "bold", true)\n})\n\nconsole.log(Automerge.spans(doc, ["text"]))\n'})}),"\n",(0,a.jsx)(t.p,{children:"And this outputs:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-javascript",children:"[\n  { type: 'block', value: { parents: [], type: 'paragraph' } },\n  { type: 'text', value: 'Hel' },\n  { type: 'text', value: 'lo', marks: { bold: true } },\n  { type: 'block', value: { type: 'paragraph', parents: [] } },\n  { type: 'text', value: 'w', marks: { bold: true } },\n  { type: 'text', value: 'orld' }\n]\n"})}),"\n",(0,a.jsx)(t.p,{children:"Here you can see that the text has been broken up into sections with distinct spans and separated by block markers."}),"\n",(0,a.jsx)(t.h3,{id:"updating-spans",children:"Updating spans"}),"\n",(0,a.jsxs)(t.p,{children:["When writing an editor integration it's often difficult to capture exactly what change has been made by the underlying editor you are integrating with. In these cases you can use ",(0,a.jsx)(t.code,{children:"Automerge.updateSpans"})," to update the block structure of the text. This function takes a sequence of spans and block markers - just like that output by ",(0,a.jsx)(t.code,{children:"Automege.spans"})," - and attempts to perform a minimal diff to update the text to the new structure."]}),"\n",(0,a.jsx)(t.admonition,{type:"warning",children:(0,a.jsxs)(t.p,{children:["One important note: ",(0,a.jsx)(t.code,{children:"Automerge.updateSpans"})," does not yet update the formatting spans of the text, just the block structure. You will need to separately reconcile the formatting span changes."]})}),"\n",(0,a.jsx)(t.p,{children:'For example, let\'s say we want to add a new paragraph marker in the string "hello world".'}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-javascript",children:'import { next as Automerge } from "@automerge/automerge"\n\nlet doc = Automerge.from({text: "hello world"})\n\ndoc = Automerge.change(doc, d => {\n    Automerge.updateSpans(d, ["text"], [\n        { type: "text", value: "hello" },\n        { type: "block", value: { type: "paragraph", parents: [] } },\n        { type: "text", value: "world" }\n    ])\n})\n\nconsole.log(Automerge.spans(doc, ["text"]))\n'})}),"\n",(0,a.jsx)(t.p,{children:"This will output:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-javascript",children:"[\n  { type: 'text', value: 'hello' },\n  { type: 'block', value: { type: 'paragraph', parents: [] } },\n  { type: 'text', value: 'world' }\n]\n"})}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.code,{children:"updateSpans"})," will try and perform minimal updates to block markers and text."]})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>i});var a=n(6540);const r={},s=a.createContext(r);function o(e){const t=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),a.createElement(s.Provider,{value:t},e.children)}}}]);