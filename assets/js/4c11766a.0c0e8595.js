"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[3850],{2199:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>d});var o=r(4848),n=r(8453);const i={sidebar_position:3},a="Prosemirror + VanillaJS + Automerge",s={id:"cookbook/rich-text-prosemirror-vanilla",title:"Prosemirror + VanillaJS + Automerge",description:'Automerge supports rich text using ProseMirror. This guide will show you how to set up a simple collaborative rich text editor in a vanilla JS app; where "vanilla" means plain JavaScript without any frameworks or libraries.',source:"@site/docs/cookbook/rich-text-prosemirror-vanilla.md",sourceDirName:"cookbook",slug:"/cookbook/rich-text-prosemirror-vanilla",permalink:"/docs/cookbook/rich-text-prosemirror-vanilla",draft:!1,unlisted:!1,editUrl:"https://github.com/automerge/automerge.github.io/edit/main/docs/cookbook/rich-text-prosemirror-vanilla.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Prosemirror + React + Automerge",permalink:"/docs/cookbook/rich-text-prosemirror-react"},next:{title:"Storage",permalink:"/docs/under-the-hood/storage"}},c={},d=[];function l(e){const t={a:"a",code:"code",em:"em",h1:"h1",p:"p",pre:"pre",...(0,n.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.h1,{id:"prosemirror--vanillajs--automerge",children:"Prosemirror + VanillaJS + Automerge"}),"\n",(0,o.jsxs)(t.p,{children:["Automerge supports rich text using ",(0,o.jsx)(t.a,{href:"https://prosemirror.net/",children:"ProseMirror"}),'. This guide will show you how to set up a simple collaborative rich text editor in a vanilla JS app; where "vanilla" means plain JavaScript without any frameworks or libraries.']}),"\n",(0,o.jsxs)(t.p,{children:["We ",(0,o.jsx)(t.em,{children:"do"})," need a bundler in order to use Automerge, so we'll assume you have set up something like Vite and that you have two files, ",(0,o.jsx)(t.code,{children:"index.html"})," and ",(0,o.jsx)(t.code,{children:"main.js"}),"."]}),"\n",(0,o.jsxs)(t.p,{children:["First, put the following in ",(0,o.jsx)(t.code,{children:"index.html"})]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-html",metastring:'title="index.html"',children:'<!doctype html>\n<html lang="en">\n  <head>\n    <title>Prosemirror + Automerge</title>\n  </head>\n  <body>\n    <div id="app"></div>\n    <script type="module" src="/main.js"><\/script>\n  </body>\n</html>\n'})}),"\n",(0,o.jsxs)(t.p,{children:["First, we need to get ",(0,o.jsx)(t.code,{children:"automerge-repo"})," set up:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",metastring:'title="main.js"',children:'import { DocHandle, Repo, isValidAutomergeUrl } from "@automerge/automerge-repo"\nimport { IndexedDBStorageAdapter } from "@automerge/automerge-repo-storage-indexeddb"\nimport { BrowserWebSocketClientAdapter } from "@automerge/automerge-repo-network-websocket"\n\nconst repo = new Repo({\n  storage: new IndexedDBStorageAdapter("automerge"),\n  network: [new BrowserWebSocketClientAdapter("wss://sync.automerge.org")],\n})\n'})}),"\n",(0,o.jsx)(t.p,{children:"Now, we'll store the automerge URL for the document we are editing in the browsers URL hash. This way, we can share the URL with others to collaborate on the document."}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",metastring:'title="main.js"',children:'// Get the document ID from the URL fragment if it\'s there. Otherwise, create\n// a new document and update the URL fragment to match.\nconst docUrl = window.location.hash.slice(1)\nif (docUrl && isValidAutomergeUrl(docUrl)) {\n  handle = repo.find(docUrl)\n} else {\n  handle = repo.create({ text: "" })\n  window.location.hash = handle.url\n}\n// Wait for the handle to be available\nawait handle.whenReady()\n'})}),"\n",(0,o.jsx)(t.p,{children:"At this point we have a document handle with a fully loaded automerge document, now we need to wire up a prosemirror editor."}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",metastring:'title="main.js"',children:'// This is the integration with automerge.\nconst mirror = new AutoMirror(["text"])\n\n// This is the prosemirror editor.\nconst view = new EditorView(document.querySelector("#editor"), {\n  state: EditorState.create({\n    doc: mirror.initialize(handle), // Note that we initialize using the mirror\n    plugins: exampleSetup({ schema: mirror.schema }), // We _must_ use the schema from the mirror\n  }),\n  // Here we intercept the transaction and apply it to the automerge document\n  dispatchTransaction: (tx) => {\n    const newState = mirror.intercept(handle, tx, view.state)\n    view.updateState(newState)\n  },\n})\n\n// If changes arrive from elsewhere, update the prosemirror state and view\nhandle.on("change", d => {\n  const newState = mirror.reconcilePatch(\n    d.patchInfo.before,\n    d.doc,\n    d.patches,\n    view.state,\n  )\n  view.updateState(newState)\n})\n'})}),"\n",(0,o.jsxs)(t.p,{children:["Now, you can open ",(0,o.jsx)(t.code,{children:"index.html"})," in your browser and start editing the document. If you open the same URL in another browser window, you should see the changes you make in one window reflected in the other."]})]})}function h(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},8453:(e,t,r)=>{r.d(t,{R:()=>a,x:()=>s});var o=r(6540);const n={},i=o.createContext(n);function a(e){const t=o.useContext(i);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:a(e.components),o.createElement(i.Provider,{value:t},e.children)}}}]);