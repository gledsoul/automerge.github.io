"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[1622],{1882:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>h,contentTitle:()=>i,default:()=>a,frontMatter:()=>d,metadata:()=>c,toc:()=>l});var r=t(4848),s=t(8453);const d={sidebar_position:3},i="Merge Rules",c={id:"under-the-hood/merge_rules",title:"Merge Rules",description:"It isn't important to understand this section to use automerge. You can just let automerge handle merging for you. But it may be interesting to understand.",source:"@site/docs/under-the-hood/merge_rules.md",sourceDirName:"under-the-hood",slug:"/under-the-hood/merge_rules",permalink:"/docs/under-the-hood/merge_rules",draft:!1,unlisted:!1,editUrl:"https://github.com/automerge/automerge.github.io/edit/main/docs/under-the-hood/merge_rules.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Storage",permalink:"/docs/under-the-hood/storage"},next:{title:"Rich Text Schema",permalink:"/docs/under-the-hood/rich_text_schema"}},h={},l=[{value:"Map merge rules",id:"map-merge-rules",level:2},{value:"List merge rules",id:"list-merge-rules",level:2},{value:"Text merge rules",id:"text-merge-rules",level:2},{value:"Counter merge rules",id:"counter-merge-rules",level:2}];function o(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",li:"li",mermaid:"mermaid",p:"p",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h1,{id:"merge-rules",children:"Merge Rules"}),"\n",(0,r.jsx)(n.admonition,{type:"info",children:(0,r.jsx)(n.p,{children:"It isn't important to understand this section to use automerge. You can just let automerge handle merging for you. But it may be interesting to understand."})}),"\n",(0,r.jsx)(n.p,{children:"How does automerge merge concurent changes? Well, let's think about what kinds of concurrent changes are possible. Automerge documents always carry their history with them, so the way to think about two concurrent versions of a document is as the set of changes since some common ancestor."}),"\n",(0,r.jsx)(n.mermaid,{value:"graph LR\n    A --\x3e B\n    B --\x3e C\n    C --\x3e D\n    D --\x3e E\n    C --\x3e F\n    F --\x3e G"}),"\n",(0,r.jsxs)(n.p,{children:["Here the common ancestor is ",(0,r.jsx)(n.code,{children:"C"})," and the concurrent changes are ",(0,r.jsx)(n.code,{children:"(D,E)"})," and ",(0,r.jsx)(n.code,{children:"(F,G)"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["Automerge documents are composed of nested maps and lists or simple values or text sequences. We can describe the merge rules by describing the rules for maps, lists, text, and counters independently. In each case we describe how to merge two sets of concurrent changes we refer to as ",(0,r.jsx)(n.code,{children:"A"})," and ",(0,r.jsx)(n.code,{children:"B"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"map-merge-rules",children:"Map merge rules"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["If ",(0,r.jsx)(n.code,{children:"A"})," sets key $x$ to a value and ",(0,r.jsx)(n.code,{children:"B"})," sets key $y$ to a value and $x \\neq y$ then add both $x$ and $y$ to the merged map"]}),"\n",(0,r.jsxs)(n.li,{children:["If ",(0,r.jsx)(n.code,{children:"A"})," deletes key $x$ and ",(0,r.jsx)(n.code,{children:"B"})," makes no change to $x$ then remove $x$ from the merged map"]}),"\n",(0,r.jsxs)(n.li,{children:["If ",(0,r.jsx)(n.code,{children:"A"})," deletes key $x$ and ",(0,r.jsx)(n.code,{children:"B"})," sets $x$ to a new value then set the value of $x$ to the new value ",(0,r.jsx)(n.code,{children:"B"})," set in the merged map"]}),"\n",(0,r.jsxs)(n.li,{children:["If both ",(0,r.jsx)(n.code,{children:"A"})," and ",(0,r.jsx)(n.code,{children:"B"})," delete key $x$ then delete $x$ from the merged map"]}),"\n",(0,r.jsxs)(n.li,{children:["If both ",(0,r.jsx)(n.code,{children:"A"})," and ",(0,r.jsx)(n.code,{children:"B"})," set the key $x$ to some value then randomly choose one value"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:'Note that "randomly choose" means "choose one arbitrarily, but in such a way that all nodes agree on the chosen value".'}),"\n",(0,r.jsx)(n.h2,{id:"list-merge-rules",children:"List merge rules"}),"\n",(0,r.jsxs)(n.p,{children:["To understand the way lists merge you need to know a little about how the operations on lists are expressed. Every element in a list has an ID and operations on the list reference these IDs. When you update an index in a list (using ",(0,r.jsx)(n.code,{children:"list[<index>] = <value>"})," in a ",(0,r.jsx)(n.code,{children:"change"})," function in the JS library) the operation which is created references the ID of the element currently at ",(0,r.jsx)(n.code,{children:"index"}),". Likewise when you delete an element from a list the delete operation which is created references the deleted element at the given index. When you ",(0,r.jsx)(n.em,{children:"insert"})," elements into a list the insert operation references the ID of the element you are inserting after"]}),"\n",(0,r.jsx)(n.p,{children:'In the following then when we say "index $x$" that really means "the ID of the element at index $x$ at the time the operation was created".'}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["If ",(0,r.jsx)(n.code,{children:"A"})," inserts an element after index $i$ and ",(0,r.jsx)(n.code,{children:"B"})," inserts an element after index $i$ then arbitrarily choose one to insert first and then insert the other immediately afterwards"]}),"\n",(0,r.jsxs)(n.li,{children:["If ",(0,r.jsx)(n.code,{children:"A"})," deletes element at index $i$ and ",(0,r.jsx)(n.code,{children:"B"})," updates the element at $i$ then set the value of $i$ to the updated value from ",(0,r.jsx)(n.code,{children:"B"})]}),"\n",(0,r.jsxs)(n.li,{children:["If ",(0,r.jsx)(n.code,{children:"A"})," and ",(0,r.jsx)(n.code,{children:"B"})," both delete element $i$ then remove it from the merged list"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Note that inserting a run of elements will maintain the insertion order of the replica which generated it. Imagine we have some list ",(0,r.jsx)(n.code,{children:"[a, b]"})," and say ",(0,r.jsx)(n.code,{children:"A"})," inserts the sequence ",(0,r.jsx)(n.code,{children:"[d, e]"})," after ",(0,r.jsx)(n.code,{children:"a"})," whilst ",(0,r.jsx)(n.code,{children:"B"})," inserts ",(0,r.jsx)(n.code,{children:"[f, g]"})," after ",(0,r.jsx)(n.code,{children:"a"}),". Initially the set of operations are:"]}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Operation ID"}),(0,r.jsx)(n.th,{children:"Reference element"}),(0,r.jsx)(n.th,{children:"Value"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"A"}),(0,r.jsx)(n.td,{children:"None"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"a"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"B"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"A"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"b"})})]})]})]}),"\n",(0,r.jsxs)(n.p,{children:["The operations after inserting on ",(0,r.jsx)(n.code,{children:"A"})," are"]}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Operation ID"}),(0,r.jsx)(n.th,{children:"Reference element"}),(0,r.jsx)(n.th,{children:"Value"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"A"}),(0,r.jsx)(n.td,{children:"None"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"a"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"B"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"A"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"b"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"D"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"B"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"d"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"E"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"D"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"e"})})]})]})]}),"\n",(0,r.jsxs)(n.p,{children:["And on ",(0,r.jsx)(n.code,{children:"B"})]}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Operation ID"}),(0,r.jsx)(n.th,{children:"Reference element"}),(0,r.jsx)(n.th,{children:"Value"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"A"}),(0,r.jsx)(n.td,{children:"None"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"a"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"B"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"A"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"b"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"F"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"B"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"f"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"G"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"F"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"g"})})]})]})]}),"\n",(0,r.jsxs)(n.p,{children:["Here you can see that while both ",(0,r.jsx)(n.code,{children:"F"})," and ",(0,r.jsx)(n.code,{children:"D"})," insert after the same reference element (",(0,r.jsx)(n.code,{children:"B"}),") the following operations reference the element that was just inserted on the local replica. That is, automerge must arbitrarily choose one of either ",(0,r.jsx)(n.code,{children:"F"})," or ",(0,r.jsx)(n.code,{children:"D"})," to be inserted after ",(0,r.jsx)(n.code,{children:"B"}),", but after that the operations stay in the same order as they were inserted on each node. Let's say that ",(0,r.jsx)(n.code,{children:"A"})," is chosen, then the final order of operations will be"]}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Operation ID"}),(0,r.jsx)(n.th,{children:"Reference element"}),(0,r.jsx)(n.th,{children:"Value"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"A"}),(0,r.jsx)(n.td,{children:"None"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"a"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"B"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"A"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"b"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"D"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"B"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"d"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"E"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"D"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"e"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"F"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"B"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"f"})})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"G"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"F"})}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"g"})})]})]})]}),"\n",(0,r.jsx)(n.p,{children:"There are cases where this algorithm does not preserve insertion order - primarily when inserting elements in reverse - but most of the time it does a good job."}),"\n",(0,r.jsx)(n.h2,{id:"text-merge-rules",children:"Text merge rules"}),"\n",(0,r.jsxs)(n.p,{children:["The characters of a text object are merged using the same logic as lists. For a description of the merge rules for marks see ",(0,r.jsx)(n.a,{href:"https://www.inkandswitch.com/peritext/",children:"Peritext"})]}),"\n",(0,r.jsx)(n.h2,{id:"counter-merge-rules",children:"Counter merge rules"}),"\n",(0,r.jsx)(n.p,{children:"Counters are very simple, we just sum all the individual operations from each node."})]})}function a(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(o,{...e})}):o(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>c});var r=t(6540);const s={},d=r.createContext(s);function i(e){const n=r.useContext(d);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),r.createElement(d.Provider,{value:n},e.children)}}}]);