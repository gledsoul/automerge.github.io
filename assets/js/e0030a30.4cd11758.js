"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[3471],{8166:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>i,contentTitle:()=>r,default:()=>l,frontMatter:()=>a,metadata:()=>d,toc:()=>c});var t=o(4848),s=o(8453);const a={sidebar_position:3},r="DocHandles",d={id:"repositories/dochandles",title:"DocHandles",description:"Once you have a Repo with a NetworkAdapter and a StorageAdapter you can get down to the business of creating and working with DocHandles.",source:"@site/docs/repositories/dochandles.md",sourceDirName:"repositories",slug:"/repositories/dochandles",permalink:"/docs/repositories/dochandles",draft:!1,unlisted:!1,editUrl:"https://github.com/automerge/automerge.github.io/edit/main/docs/repositories/dochandles.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Networking",permalink:"/docs/repositories/networking"},next:{title:"Ephemeral Data",permalink:"/docs/repositories/ephemeral"}},i={},c=[{value:"Creating a <code>DocHandle</code>",id:"creating-a-dochandle",level:2},{value:"Waiting for a <code>DocHandle</code>",id:"waiting-for-a-dochandle",level:2},{value:"<code>DocHandle</code> states",id:"dochandle-states",level:3},{value:"Waiting for a handle to be ready",id:"waiting-for-a-handle-to-be-ready",level:3}];function h(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",li:"li",mermaid:"mermaid",p:"p",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.h1,{id:"dochandles",children:[(0,t.jsx)(n.code,{children:"DocHandle"}),"s"]}),"\n",(0,t.jsxs)(n.p,{children:["Once you have a ",(0,t.jsx)(n.code,{children:"Repo"})," with a ",(0,t.jsx)(n.code,{children:"NetworkAdapter"})," and a ",(0,t.jsx)(n.code,{children:"StorageAdapter"})," you can get down to the business of creating and working with ",(0,t.jsx)(n.a,{href:"https://automerge.org/automerge-repo/classes/_automerge_automerge_repo.DocHandle.html",children:(0,t.jsx)(n.code,{children:"DocHandle"})}),"s."]}),"\n",(0,t.jsxs)(n.p,{children:["It's useful to understand a little about why we need a ",(0,t.jsx)(n.code,{children:"DocHandle"}),". ",(0,t.jsx)(n.code,{children:"@automerge/automerge"}),' documents are fairly inert data structures. You can create a document, you can mutate it, you can generate sync messages to send elsewhere and you can receive sync messages from elsewhere. None of this is very "live" though. Because the document has no concept of a network, or of storage, you can\'t say "every time I change a document, tell everyone else about it and save the change to storage". This "live document" is what a ',(0,t.jsx)(n.code,{children:"DocHandle"})," is. A ",(0,t.jsx)(n.code,{children:"DocHandle"})," is a wrapper around a document managed by a ",(0,t.jsx)(n.code,{children:"Repo"}),'. It provides the following kinds of "liveness":']}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Whenever you change the document using ",(0,t.jsx)(n.a,{href:"https://automerge.org/automerge-repo/classes/_automerge_automerge_repo.DocHandle.html#change",children:(0,t.jsx)(n.code,{children:"DocHandle.change"})})," or ",(0,t.jsx)(n.a,{href:"https://automerge.org/automerge-repo/classes/_automerge_automerge_repo.DocHandle.html#changeAt",children:(0,t.jsx)(n.code,{children:"DocHandle.changeAt"})})," the changes will be saved to the attached ",(0,t.jsx)(n.code,{children:"StorageAdapter"})," and sent to any connected ",(0,t.jsx)(n.code,{children:"NetworkAdapter"}),"s"]}),"\n",(0,t.jsxs)(n.li,{children:["Whenever a change is received from a connected peer the ",(0,t.jsx)(n.code,{children:"DocHandle"}),' will fire a "change" event']}),"\n",(0,t.jsxs)(n.li,{children:["There is a concept of an ephemeral message, which you can send using ",(0,t.jsx)(n.code,{children:"DocHandle.broadcast"}),". Whenever a ",(0,t.jsx)(n.code,{children:"DocHandle"})," receives an ephemeral message it will fire a ",(0,t.jsx)(n.code,{children:'"ephemeral-message"'})," event"]}),"\n",(0,t.jsxs)(n.li,{children:["You can wait for a ",(0,t.jsx)(n.code,{children:"DocHandle"})," to be loaded, or to be retrieved from another peer"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"DocHandle"}),"s have a ",(0,t.jsx)(n.code,{children:"URL"}),", which can be used to uniquely refer to the document it wraps when requesting it from another peer"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"DocHandle"}),"s are very useful, how do you obtain one?"]}),"\n",(0,t.jsxs)(n.h2,{id:"creating-a-dochandle",children:["Creating a ",(0,t.jsx)(n.code,{children:"DocHandle"})]}),"\n",(0,t.jsxs)(n.p,{children:["This is the easy one, just call ",(0,t.jsx)(n.a,{href:"https://automerge.org/automerge-repo/classes/_automerge_automerge_repo.Repo.html#create",children:(0,t.jsx)(n.code,{children:"Repo.create"})}),". This creates a new document, stores it, and then enqueues messages to all connected peers informing them of the new document."]}),"\n",(0,t.jsxs)(n.h2,{id:"waiting-for-a-dochandle",children:["Waiting for a ",(0,t.jsx)(n.code,{children:"DocHandle"})]}),"\n",(0,t.jsxs)(n.p,{children:["Typically you are ",(0,t.jsx)(n.em,{children:"not"})," creating a new document, but working with an existing one. Maybe the document URL was stored in ",(0,t.jsx)(n.code,{children:"localStorage"}),", maybe the URL was in the hash fragment of the browser, etc. In this case you use ",(0,t.jsx)(n.a,{href:"https://automerge.org/automerge-repo/classes/_automerge_automerge_repo.Repo.html#find",children:(0,t.jsx)(n.code,{children:"Repo.find"})})," to lookup the document. This means the ",(0,t.jsx)(n.code,{children:"DocHandle"})," can be in several different states, to understand this we'll first look at the states in detail, then some convenience methods ",(0,t.jsx)(n.code,{children:"DocHandle"})," exposes for waiting for different states."]}),"\n",(0,t.jsxs)(n.h3,{id:"dochandle-states",children:[(0,t.jsx)(n.code,{children:"DocHandle"})," states"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"Repo.find"})," will do two things simultaneously:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Look in the attached ",(0,t.jsx)(n.code,{children:"StorageAdapter"})," to see if we have any data for the document"]}),"\n",(0,t.jsx)(n.li,{children:"Send a request to any connected peers to ask if they have the document"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["These actions are asynchronous, as they complete the state of the document changes. This state is represented most explicitly in the ",(0,t.jsx)(n.a,{href:"https://automerge.org/automerge-repo/enums/_automerge_automerge_repo.HandleState.html",children:(0,t.jsx)(n.code,{children:"HandleState"})})," enum, which has the following states:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"IDLE"})," - This is really just a start state, every dochandle immediately transitions to another state"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"AWAITING_NETWORK"})," - in this state we are waiting for the ",(0,t.jsx)(n.code,{children:"NetworkAdapter"}),"s to be ready to process messages. This typically occurs at application startup. Most ",(0,t.jsx)(n.code,{children:"NetworkAdapter"}),"s have an asynchronous startup period. The ",(0,t.jsx)(n.code,{children:"Repo"})," waits until every ",(0,t.jsx)(n.code,{children:"NetworkAdapter"})," has emitted a ",(0,t.jsx)(n.code,{children:"ready"})," event before beginning to request documents"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"LOADING"})," - we are waiting for storage to finish trying to load this document"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"REQUESTING"})," - we are waiting to hear back from other peers about this document"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"READY"})," - The document is available, either we created it, found it in storage, or someone sent it to us"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"DELETED"})," - The document was removed from the repo"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"UNAVAILABLE"})," - We don't have the document in storage and none of our peers have the document either"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"The transitions between these states look like this:"}),"\n",(0,t.jsx)(n.mermaid,{value:"stateDiagram-V2\n    direction LR\n    [*] --\x3e LOADING: Repo.find\n    [*] --\x3e READY: Repo.create\n    LOADING --\x3e AWAITING_NETWORK\n    AWAITING_NETWORK --\x3e REQUESTING: network ready\n    AWAITING_NETWORK --\x3e DELETED\n    LOADING --\x3e READY: found in storage\n    LOADING --\x3e REQUESTING: not found in storage\n    LOADING --\x3e UNAVAILABLE: no peers had the doc\n    LOADING --\x3e DELETED\n    UNAVAILABLE --\x3e READY: Received sync for this doc\n    UNAVAILABLE --\x3e DELETED\n    REQUESTING --\x3e READY: Received sync for this doc\n    READY --\x3e DELETED"}),"\n",(0,t.jsxs)(n.p,{children:["Note that every state can transition to ",(0,t.jsx)(n.code,{children:"DELETED"}),", either via ",(0,t.jsx)(n.code,{children:"DocHandle.delete"})," or ",(0,t.jsx)(n.code,{children:"Repo.delete"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["One other point to note is that a ",(0,t.jsx)(n.code,{children:"DocHandle"})," can be unavailable because we didn't have it in storage and no peers responded to our request for it, but then another peer comes online and sends us sync messages for the document and so it transitions to ",(0,t.jsx)(n.code,{children:"READY"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["You can check what state a handle is in using ",(0,t.jsx)(n.a,{href:"https://automerge.org/automerge-repo/classes/_automerge_automerge_repo.DocHandle.html#inState",children:(0,t.jsx)(n.code,{children:"DocHandle.inState"})}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"waiting-for-a-handle-to-be-ready",children:"Waiting for a handle to be ready"}),"\n",(0,t.jsx)(n.p,{children:"If all we care about is whether the document is ready then we can use a few different methods."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"DocHandle.isReady()"})," is a synchronous method which will return ",(0,t.jsx)(n.code,{children:"true"})," if the document is ready"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"DocHandle.whenReady()"})," is an asynchronous method that will return when the handle is ready"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"DocHandle.doc()"})," is an asynchronous method which will return the value of the document when it is ready"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"DocHandle.docSync()"})," is a synchronous method which returns the value of the document if it is ready. This method ",(0,t.jsx)(n.em,{children:"will throw if the handle is not ready"}),". Therefore you should guard calls to ",(0,t.jsx)(n.code,{children:"docSync"})," with calls to ",(0,t.jsx)(n.code,{children:"isReady"})]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Once the document is ready the value of the document (either ",(0,t.jsx)(n.code,{children:"DocHandle.doc()"})," or ",(0,t.jsx)(n.code,{children:"DocHandle.docSync()"}),") will be ",(0,t.jsx)(n.code,{children:"undefined"})," if the document was unavailable, but otherwise will be an automerge document."]})]})}function l(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},8453:(e,n,o)=>{o.d(n,{R:()=>r,x:()=>d});var t=o(6540);const s={},a=t.createContext(s);function r(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);