"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[2930],{8312:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>c,frontMatter:()=>a,metadata:()=>r,toc:()=>m});var t=o(4848),i=o(8453);const a={sidebar_position:2},s="Library Initialization",r={id:"library_initialization",title:"Library Initialization",description:"Automerge is implemented in Rust and compiled to WebAssembly for use in javascript environments. Unfortunately the way that WebAssembly modules are loaded varies across environments. In some situations this can be handled by your build tool, but in others you may need to manually load the module. This page describes how to load automerge in various environments, and also an escape hatch which should work everywhere.",source:"@site/docs/library_initialization.md",sourceDirName:".",slug:"/library_initialization",permalink:"/docs/library_initialization",draft:!1,unlisted:!1,editUrl:"https://github.com/automerge/automerge.github.io/edit/main/docs/library_initialization.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Concepts",permalink:"/docs/concepts"},next:{title:"The JavaScript packages",permalink:"/docs/the_js_packages"}},l={},m=[{value:"Common Environments",id:"common-environments",level:2},{value:"Node.js",id:"nodejs",level:3},{value:"WebPack",id:"webpack",level:3},{value:"Vite",id:"vite",level:3},{value:"Cloudflare Workers",id:"cloudflare-workers",level:3},{value:"Deno",id:"deno",level:3},{value:"Val.town",id:"valtown",level:3},{value:"The escape hatch",id:"the-escape-hatch",level:2},{value:"Using the raw WebAssembly",id:"using-the-raw-webassembly",level:3},{value:"Using the base64 encoded WebAssembly",id:"using-the-base64-encoded-webassembly",level:3}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"library-initialization",children:"Library Initialization"}),"\n",(0,t.jsxs)(n.p,{children:["Automerge is implemented in Rust and compiled to WebAssembly for use in javascript environments. Unfortunately the way that WebAssembly modules are loaded varies across environments. In some situations this can be handled by your build tool, but in others you may need to manually load the module. This page describes how to load automerge in various environments, and also an ",(0,t.jsx)(n.a,{href:"#the-escape-hatch",children:"escape hatch"})," which should work everywhere."]}),"\n",(0,t.jsx)(n.h2,{id:"common-environments",children:"Common Environments"}),"\n",(0,t.jsx)(n.h3,{id:"nodejs",children:"Node.js"}),"\n",(0,t.jsxs)(n.p,{children:["In node you don't need to do anything special as WebAssembly is supported natively, you just ",(0,t.jsx)(n.code,{children:'import { next as A } from "@automerge/automerge"'})," and you're good to go."]}),"\n",(0,t.jsx)(n.h3,{id:"webpack",children:"WebPack"}),"\n",(0,t.jsxs)(n.p,{children:["If you're building using webpack you need to enable the ",(0,t.jsx)(n.code,{children:"asyncWebAssembly"})," feature. This is done by adding the following to your ",(0,t.jsx)(n.code,{children:"webpack.config.js"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"{\n    experiments: {\n        asyncWebAssembly: true\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"vite",children:"Vite"}),"\n",(0,t.jsxs)(n.p,{children:["In vite you'll need to add two plugins, ",(0,t.jsx)(n.code,{children:"vite-plugin-wasm"})," and ",(0,t.jsx)(n.code,{children:"vite-plugin-top-level-await"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"yarn add vite-plugin-wasm vite-plugin-top-level-await\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Then in your ",(0,t.jsx)(n.code,{children:"vite.config.js"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"import { defineConfig } from 'vite'\nimport wasm from 'vite-plugin-wasm'\nimport topLevelAwait from 'vite-plugin-top-level-await'\n\nexport default defineConfig({\n  ...\n  plugins: [wasm(), topLevelAwait()],\n  ...\n})\n"})}),"\n",(0,t.jsx)(n.h3,{id:"cloudflare-workers",children:"Cloudflare Workers"}),"\n",(0,t.jsxs)(n.p,{children:["Here you should be good to go by just importing ",(0,t.jsx)(n.code,{children:"@automerge/automerge"})," as normal."]}),"\n",(0,t.jsx)(n.admonition,{type:"warning",children:(0,t.jsx)(n.p,{children:"If you see obscure looking rust stack traces complaining about being unable to create random bytes while constructing a UUID then this is because you are trying to create a document (either a new one, or loading or forking one) outside of a handler. If you run the problematic code in a handler you should be fine."})}),"\n",(0,t.jsx)(n.h3,{id:"deno",children:"Deno"}),"\n",(0,t.jsx)(n.p,{children:"If your Deno instance allows access to the filesystem (the default for local development) then you can import Automerge from an npm specifier like so:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'import { next as Am } from "npm:@automerge/automerge"\n'})}),"\n",(0,t.jsx)(n.p,{children:"However, if your Deno process doesn't have filesystem permission then you'll need to manually initialize the WebAssembly module. One way of doing that is:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'import { automergeWasmBase64 } from "npm:@automerge/automerge";\nimport { next as Am } from "npm:@automerge/automerge";\n\nawait Am.initializeBase64Wasm(automergeWasmBase64);\n'})}),"\n",(0,t.jsx)(n.h3,{id:"valtown",children:"Val.town"}),"\n",(0,t.jsx)(n.p,{children:'Val.town is a cloud-based Deno execution platform. Here\'s the text of a simple "val" which returns the contents of the documentId passed via the path.'}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'import { BrowserWebSocketClientAdapter } from "npm:@automerge/automerge-repo-network-websocket";\nimport { isValidAutomergeUrl, Repo } from "npm:@automerge/automerge-repo/slim";\n\n/* set up Automerge\'s internal wasm guts manually */\nimport { automergeWasmBase64 } from "npm:@automerge/automerge/automerge.wasm.base64.js";\nimport * as automerge from "npm:@automerge/automerge/slim";\nawait automerge.next.initializeBase64Wasm(automergeWasmBase64);\n\n/* This example will return the contents of a documentID passed in as the path as JSON. */\nexport default async function(req: Request): Promise<Response> {\n  const docId = new URL(req.url).pathname.substring(1);\n\n  if (!isValidAutomergeUrl("automerge:" + docId)) {\n    return Response.error();\n  }\n\n  const repo = new Repo({ network: [new BrowserWebSocketClientAdapter("wss://sync.automerge.org")] });\n  const handle = repo.find(docId);\n  const contents = await handle.doc();\n  return Response.json(contents);\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"the-escape-hatch",children:"The escape hatch"}),"\n",(0,t.jsx)(n.p,{children:"If you're in an environment which doesn't support importing WebAssembly modules as ES modules then you need to initialize the WebAssembly manually. There are two parts to this:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Change all imports in your application of ",(0,t.jsx)(n.code,{children:"@automerge/automerge"})," and ",(0,t.jsx)(n.code,{children:"@automerge/automerge-repo"}),' to the "slim" variants (',(0,t.jsx)(n.code,{children:"@automerge/automerge/slim"})," and ",(0,t.jsx)(n.code,{children:"@automerge/automerge-repo/slim)"})]}),"\n",(0,t.jsx)(n.li,{children:"Obtain the WebAssembly module and initialize it manually, then wait for initialization to complete."}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["For this latter part we expose two exports from the ",(0,t.jsx)(n.code,{children:"@automerge/automerge"})," package which can be used to obtain the raw WebAssembly. ",(0,t.jsx)(n.code,{children:"@automerge/automerge/automerge.wasm"})," is a binary version of the WebAssembly file, whilst ",(0,t.jsx)(n.code,{children:"@automerge/automerge/automerge.wasm.base64.js"})," is a JS modules with a single export called ",(0,t.jsx)(n.code,{children:"automergeWasmBase64"})," which is a base64 encoded version of the WebAssembly file."]}),"\n",(0,t.jsxs)(n.p,{children:["Once you've obtained the WebAssembly file you initialize it by passing it to either ",(0,t.jsx)(n.code,{children:"initializeWasm"})," - which expects a WebAssembly module or a URL to fetch - or to ",(0,t.jsx)(n.code,{children:"initializeBase64Wasm"})," which expects a base64 encoded string."]}),"\n",(0,t.jsx)(n.h3,{id:"using-the-raw-webassembly",children:"Using the raw WebAssembly"}),"\n",(0,t.jsxs)(n.p,{children:["Here's an example of using the raw WebAssembly in a Vite application. Here we can use the ",(0,t.jsx)(n.code,{children:"?url"})," suffix on an import to obtain the URL to an asset."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'// Note the ?url suffix\nimport wasmUrl from "@automerge/automerge/automerge.wasm?url";\n// Note the `/slim` suffixes\nimport { next as Automerge } from "@automerge/automerge/slim";\nimport { Repo } from `@automerge/automerge-repo/slim`;\n\nawait next.initializeWasm(wasmUrl)\n\n// Now we can get on with our lives\n\nconst repo = new Repo({..})\n'})}),"\n",(0,t.jsx)(n.h3,{id:"using-the-base64-encoded-webassembly",children:"Using the base64 encoded WebAssembly"}),"\n",(0,t.jsx)(n.p,{children:"Here's an example of using the raw WebAssembly in an application where we can load JavaScript files but nothing else."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'import { automergeWasmBase64 } from "@automerge/automerge/automerge.wasm.base64.js";\n// Note the `/slim` suffixes\nimport { next as Automerge } from "@automerge/automerge/slim";\nimport { Repo } from `@automerge/automerge-repo/slim`;\n\nawait next.initializeBase64Wasm(automergeWasmBase64)\n\n// Now we can get on with our lives\nconst repo = new Repo({..})\n'})})]})}function c(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,o)=>{o.d(n,{R:()=>s,x:()=>r});var t=o(6540);const i={},a=t.createContext(i);function s(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);