"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[9599],{9723:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>r,default:()=>h,frontMatter:()=>i,metadata:()=>l,toc:()=>c});var s=t(4848),a=t(8453);const i={},r="Document Data Model",l={id:"documents/index",title:"Document Data Model",description:"Automerge documents are quite similar to JSON objects. A document always consists of a root map which is a map from strings to other automerge values, which can themselves be composite types.",source:"@site/docs/documents/index.md",sourceDirName:"documents",slug:"/documents/",permalink:"/docs/documents/",draft:!1,unlisted:!1,editUrl:"https://github.com/automerge/automerge.github.io/edit/main/docs/documents/index.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"The JavaScript packages",permalink:"/docs/the_js_packages"},next:{title:"Simple Values",permalink:"/docs/documents/values"}},o={},c=[{value:"Maps",id:"maps",level:2},{value:"Lists",id:"lists",level:2},{value:"Text",id:"text",level:2},{value:"Timestamps",id:"timestamps",level:2},{value:"Counter",id:"counter",level:2},{value:"Javascript language mapping",id:"javascript-language-mapping",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"document-data-model",children:"Document Data Model"}),"\n",(0,s.jsx)(n.p,{children:"Automerge documents are quite similar to JSON objects. A document always consists of a root map which is a map from strings to other automerge values, which can themselves be composite types."}),"\n",(0,s.jsx)(n.p,{children:"The types in automerge are:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Composite types","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Maps"}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"lists",children:"List"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"./text",children:"Text"})}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Scalar (non-composite) types:","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"IEEE 754 64 bit floating point numbers"}),"\n",(0,s.jsx)(n.li,{children:"Unsigned integers"}),"\n",(0,s.jsx)(n.li,{children:"Signed integers"}),"\n",(0,s.jsx)(n.li,{children:"Booleans Strings"}),"\n",(0,s.jsx)(n.li,{children:"Timestamps"}),"\n",(0,s.jsx)(n.li,{children:"Counters"}),"\n",(0,s.jsx)(n.li,{children:"Byte arrays"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["See ",(0,s.jsx)(n.a,{href:"#javascript-language-mapping",children:"below"})," for how these types map to JavaScript types."]}),"\n",(0,s.jsx)(n.h2,{id:"maps",children:"Maps"}),"\n",(0,s.jsx)(n.p,{children:'Maps have string keys and any automerge type as a value. "string" here means a unicode string. The underlying representation in automerge is as UTF-8 byte sequences but they are exposed as utf-16 strings in javascript.'}),"\n",(0,s.jsx)(n.h2,{id:"lists",children:"Lists"}),"\n",(0,s.jsx)(n.p,{children:"A list is an ordered sequence of automerge values. The underlying data structure is an RGA sequence, which means that concurrent insertions and deletions can be merged in a manner which attempts to preserve user intent."}),"\n",(0,s.jsx)(n.h2,{id:"text",children:"Text"}),"\n",(0,s.jsxs)(n.p,{children:["Text is an implementation of the ",(0,s.jsx)(n.a,{href:"https://www.inkandswitch.com/peritext/",children:"peritext"})," CRDT. This is conceptually similar to a ",(0,s.jsx)(n.a,{href:"#lists",children:"list"})," where each element is a single unicode scalar value representing a single character. In addition to the characters ",(0,s.jsx)(n.code,{children:"Text"}),' also supports "marks". Marks are tuples of the form ',(0,s.jsx)(n.code,{children:"(start, end, name, value)"})," which have the following meanings:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"start"})," - the index of the beginning of the mark"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"end"})," - the index of the end of the mark"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"name"})," - the name of the mark"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"value"})," - any scalar (as in automerge scalar) value"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["For example, a bold mark from characters 1 to 5 might be represented as ",(0,s.jsx)(n.code,{children:'(1, 5, "bold", true)'}),"."]}),"\n",(0,s.jsx)(n.p,{children:"Note that the restriction to scalar values for the value of a mark will be lifted in future, although mark values will never be mutable - instead you should always create a new mark when updating a value. For now, if you need complex values in a mark you should serialize the value to a string."}),"\n",(0,s.jsx)(n.h2,{id:"timestamps",children:"Timestamps"}),"\n",(0,s.jsx)(n.p,{children:"Timestamps are the integer number of milliseconds since the unix epoch (midnight 1970, UTC)."}),"\n",(0,s.jsx)(n.h2,{id:"counter",children:"Counter"}),"\n",(0,s.jsx)(n.p,{children:"Counters are a simple CRDT which just merges by adding all concurrent operations. They can be incremented and decremented."}),"\n",(0,s.jsx)(n.h2,{id:"javascript-language-mapping",children:"Javascript language mapping"}),"\n",(0,s.jsxs)(n.p,{children:["The mapping to javascript is accomplished with the use of proxies. This means that in the javascript library maps appear as ",(0,s.jsx)(n.code,{children:"object"}),"s and lists appear as ",(0,s.jsx)(n.code,{children:"Array"}),"s. There is only one numeric type in javascript - ",(0,s.jsx)(n.code,{children:"number"})," - so the javascript library guesses a bit. If you insert a javascript ",(0,s.jsx)(n.code,{children:"number"})," for which ",(0,s.jsx)(n.a,{href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger",children:(0,s.jsx)(n.code,{children:"Number.isInteger"})})," returns ",(0,s.jsx)(n.code,{children:"true"})," then the number will be inserted as an integer, otherwise it will be a floating point value."]}),"\n",(0,s.jsxs)(n.p,{children:["How ",(0,s.jsx)(n.code,{children:"Text"})," and ",(0,s.jsx)(n.code,{children:"String"})," are represented will depend on whether you are using ",(0,s.jsxs)(n.a,{href:"/docs/the_js_packages#the-next-api",children:["the ",(0,s.jsx)(n.code,{children:"next"})," API"]})]}),"\n",(0,s.jsxs)(n.p,{children:["Timestamps are represented as javascript ",(0,s.jsx)(n.code,{children:"Date"}),"s."]}),"\n",(0,s.jsxs)(n.p,{children:["Counters are represented as instances of the ",(0,s.jsx)(n.code,{children:"Counter"})," class."]}),"\n",(0,s.jsx)(n.p,{children:"Putting it all together, here's an example of an automerge document containing all the value types:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:'import * as A from "@automerge/automerge/next";\n\nlet doc = A.from({\n  map: {\n    key: "value",\n    nested_map: { key: "value" },\n    nested_list: [1],\n  },\n  list: ["a", "b", "c", { nested: "map" }, ["nested list"]],\n  // Note we are using the `next` API for text, so text sequences are strings\n  text: "some text",\n  // In the `next` API non mergable strings are instances of `RawString`.\n  // You should generally not need to use these. They are retained for backward\n  // compatibility\n  raw_string: new A.RawString("rawstring"),\n  integer: 1,\n  float: 2.3,\n  boolean: true,\n  bytes: new Uint8Array([1, 2, 3]),\n  date: new Date(),\n  counter: new A.Counter(1),\n  none: null,\n});\n\ndoc = A.change(doc, (d) => {\n  // Insert \'Hello\' at the beginning of the string\n  A.splice(d, ["text"], 0, 0, "Hello ");\n  d.counter.increment(20);\n  d.map.key = "new value";\n  d.map.nested_map.key = "new nested value";\n  d.list[0] = "A";\n  d.list.insertAt(0, "Z");\n  d.list[4].nested = "MAP";\n  d.list[5][0] = "NESTED LIST";\n});\n\nconsole.log(doc);\n\n// Prints\n// {\n//   map: {\n//     key: \'new value\',\n//     nested_map: { key: \'new nested value\' },\n//     nested_list: [ 1 ]\n//   },\n//   list: [ \'Z\', \'A\', \'b\', \'c\', { nested: \'MAP\' }, [ \'NESTED LIST\' ] ],\n//   text: \'Hello world\',\n//   raw_string: RawString { val: \'rawstring\' },\n//   integer: 1,\n//   float: 2.3,\n//   boolean: true,\n//   bytes: Uint8Array(3) [ 1, 2, 3 ],\n//   date: 2023-09-11T13:35:12.229Z,\n//   counter: Counter { value: 21 },\n//   none: null\n// }\n'})})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>l});var s=t(6540);const a={},i=s.createContext(a);function r(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);